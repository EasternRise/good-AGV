/****************************************Copyright (c)**************************************************
**                                     XJTU Robot Team
**-----------------------------------------File Info----------------------------------------------------
** File name:			gpio.c
** Last modified Date:  2013-4-10
** Descriptions:		
** Created by:		   	dong		
********************************************************************************************************/
#include "basic.h"


/*********************************************************************************************************
** 函数名称: IO_Init函数
** 功能描述: 
			 GPC0-4，8-14用来读取接触开关，接近开关等开关量传感器
			 GPF4是给板子上的STM32的中断线
***************************************                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *****************************************************************/
void IO_Init(void)
{    
    rGPDDAT &= (~(0xffff));						//初始化数据端口输出均为低电平
   
    rGPDCON &= (~(0xffffffff));					//初始化全部端口为输出口,两位决定一个端口的状态,32位共16个端口
	rGPDCON |= 0x55555555;						
    //rGPDUP  &= (~(0xffff));					//使能附加上拉功能
   
   
   	/* 00是输入，01是输出
	** GPCCON 	0	1	2	3	4	8	9	10	11	12	13	14
	**			O	I	O	I	O	I	O	 O	 O	 O	 O	O
	*/
   
    rGPCCON &= (~(0xffffffff));
 	rGPCCON |= 1<<0 | 0<<2 | 1<<4 | 0<<6 | 1<<8  | 0<<16 | 1<<18 | 1<<20 | 1<<22 | 1<<24 | 1<<26 | 1<<28;
    //1<<0代表0位是1，1<<4代表第4位是1。0<<2没有实际意义，只是为了说明第2位是0。
    
    rGPJDAT=0x0;
    rGPJCON &= (~(0xffffffff));                //初始化全部端口为输出端口
	rGPJCON |= 0x55555555;					
	rGPJUP  &= (~(0xffff));
	
	rGPGCON &= (~(0xffffffff));           //初始化为输出端口
	rGPGCON |= 0x55555555; 				
	
	 //GPF4是ARM给STM32的中断线，触发为上升沿,GPF4初始化为输出
    rGPFCON &= ~(0x3<<8);
    rGPFCON |= 0x1<<8;		//第8位置1
	
    rGPFDAT &= ~(0x1<<4);
	
}



/******************************************************
**	接近开关和接近开关综述:
**    光隔板上共有3块4051 可以读取24个口,其中有6个用于ST接触开关
**	  13个用于接近开关,每次读取的时候选通对应的地址便可接通 
**
** 
*******************************************************/



/*************************************************************
**函数名称：SA_Read()
**函数参数：port  要读取的接近开关端口号 从1~13
**功能描述：读取接近开关的值
**************************************************************/

uint32 SA_ENCODE[13] ={0x0,0x6010,0x4010,0x6000,0x4000,0x2010,0x0010,0x2000,0x0000,  0x1804,0x1004,0x1800,0x1000};
		          //S3:000,  111 ,  110 , 101  , 100  , 011  , 010  , 001  , 000 ；S2：111 ， 110，  101，  100
			//        :      000 ,  001 , 010  , 011  , 100  , 101  , 110  , 111 ；    000 ， 001，  010，  011
uint8 SA_Read(uint8 port)
{
	U32 state,i;
	uint8  value;
	if( port<9  &&  port>0 ) 
	{
		rGPCDAT &= ~(0x6010 );  
		rGPCDAT |= SA_ENCODE[port]; //输出选定端口地址
		for(i=0;i<100;i++);			//延时等待传值
		state = rGPCDAT;			//取传值后的寄存器值
		if(state & (1<<8))			//取出S3_com位的值，并判断是否为0
			value = 1;
		else 
			value = 0;
	}
	else{
		rGPCDAT &= ~(0x1804);  
		rGPCDAT |= SA_ENCODE[port];
		for(i=0;i<100;i++); 
		state = rGPCDAT;
		if(state & (1<<3))
			value = 1;
		else 
			value = 0;		
	} 		
	return value;
}


/*************************************************************
**函数名称：ST_Read()
**函数参数：port  要读取的接触开关端口号 从1~6
**功能描述：读取接触开关的值
**************************************************************/

uint32 ST_ENCODE[7]={0x0, 0x804,  0x4, 0x800, 0x0000,  0x601,0x401};
			    //S2：      011,  010,  001,   000, S1：111 ,  110
			    //          100,  101,  110,   111,     000 ,  001
 					  
 					  
uint8 ST_Read(uint8 port)
{
	U32 state,i;
	uint8  value;
	if(port>0 && port<5)
	{
		rGPCDAT &= ~(0x1804);
		rGPCDAT |= ST_ENCODE[port]; 
		for(i=0;i<100;i++);
		state = rGPCDAT;
		if(state & (1<<3))
			value = 1;
		else 
			value = 0;
	}
	else{
		rGPCDAT &= ~(0x601);
		rGPCDAT |= ST_ENCODE[port];
		for(i=0;i<100;i++); 		
		state = rGPCDAT;
		if(state & (1<<1))
			value = 1;
		else 
			value = 0;		
	} 		
	return value;
}




/********************************************************
*
*功能描述，LED灯显示 与熄灭  LED与ARM相连的一端要接低电平
*********************************************************/


void LED_Set(U8  LED_num)
{
	switch(LED_num){
		
		case 1 :
			rGPGDAT  |= (1<<12);
			break ;
			
		case 2:
			rGPJDAT  |= (1<<10);
			break;
			
		case 3:
			rGPJDAT  |= (1<<9);
			break;
		case 4:
			rGPJDAT  |= (1<<8);
		default: break;						
	}
}



void LED_Clear(U8  LED_num)
{
	switch(LED_num){
		
		case 1 :
			rGPGDAT  &= (~(1<<12));
			break ;
			
		case 2:
			rGPJDAT  &= (~(1<<10));
			break;
			
		case 3:
			rGPJDAT  &= (~(1<<9));
			break;
		case 4:
			rGPJDAT  &= (~(1<<8));
		default: break;						
	}
}

